<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://s2.loli.net/2022/04/08/oHUjIYRyi3T918K.png" />
<title>通过一个小项目学习Makefile | SunshinePlusIce</title>
<meta name="title" content="通过一个小项目学习Makefile" />
<meta name="description" content="最近在linux上写了一个小项目，接触了make等工具，这次就通过一些辅助例子和我这个小项目来介绍一下makefile的基本写法。
makefile何为物  在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。
 这是来自维基百科的介绍， 其实说直白一点，就是一个编译工具。因此， 我们下载下来一个项目后， 一般会附带一个makefile文件。 更普遍的， 是附带一个configure文件，用于检查并生成需要的makefile文件，然后通过命令行执行make来编译。 执行make install来安装。
makefile的用途 考虑下面的文件目录：
. └── src └── main.cpp 如果我们位于当前目录，要编译main.cpp实在是再简单不过，于是我们张口就莱: g&#43;&#43; src/main.cpp -o main。　这样就成功编译了main.cpp文件。显然这样敲命令不会比使用makefile麻烦多少，然而这是还没到makefile大显身手的时候。
makefile的基本写法 当然，我们的目的是学习makefile，那么就以编译上面的main.cpp为例，介绍一下makefile的基本写法吧！
# 注释 target(目标): dependencies(依赖文件) &lt;tab&gt;command1 # 命令1 &lt;tab&gt;command2 # 命令2 一下子看不懂不要紧，且听我道来。target通常是我们要生成的文件的名字， dependencies是生成target所需的文件名列表， 如果为空就不需要写， 有多个文件用空格隔开。因此， 要把main.cpp编译成可执行文件main可以写成这样：main: main.cpp。
写好了target和dependencies后是换行， 接下来就要告诉makefile这个文件是如何生成出来的了。因此要键入编译指令。此处要注意&lt;tab&gt;是指一个tab键而不是四个空格， 这跟python有点像，熟悉python的小伙伴应该对此比较满意233。 因此command1和command2都是指命令行命令。
通过上面的介绍， 我们可以写出下面的makefile文件：
main: src/main.cpp g&#43;&#43; src/main.cpp -o main 保存后， 进入控制台执行make, make就会自动的执行makefile文件中的第一个target。
一个稍复杂的例子 考虑下面的文件目录：
. └── src ├── a.cpp ├── a.h ├── b." />
<meta name="keywords" content="" />


<meta property="og:title" content="通过一个小项目学习Makefile" />
<meta property="og:description" content="最近在linux上写了一个小项目，接触了make等工具，这次就通过一些辅助例子和我这个小项目来介绍一下makefile的基本写法。
makefile何为物  在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。
 这是来自维基百科的介绍， 其实说直白一点，就是一个编译工具。因此， 我们下载下来一个项目后， 一般会附带一个makefile文件。 更普遍的， 是附带一个configure文件，用于检查并生成需要的makefile文件，然后通过命令行执行make来编译。 执行make install来安装。
makefile的用途 考虑下面的文件目录：
. └── src └── main.cpp 如果我们位于当前目录，要编译main.cpp实在是再简单不过，于是我们张口就莱: g&#43;&#43; src/main.cpp -o main。　这样就成功编译了main.cpp文件。显然这样敲命令不会比使用makefile麻烦多少，然而这是还没到makefile大显身手的时候。
makefile的基本写法 当然，我们的目的是学习makefile，那么就以编译上面的main.cpp为例，介绍一下makefile的基本写法吧！
# 注释 target(目标): dependencies(依赖文件) &lt;tab&gt;command1 # 命令1 &lt;tab&gt;command2 # 命令2 一下子看不懂不要紧，且听我道来。target通常是我们要生成的文件的名字， dependencies是生成target所需的文件名列表， 如果为空就不需要写， 有多个文件用空格隔开。因此， 要把main.cpp编译成可执行文件main可以写成这样：main: main.cpp。
写好了target和dependencies后是换行， 接下来就要告诉makefile这个文件是如何生成出来的了。因此要键入编译指令。此处要注意&lt;tab&gt;是指一个tab键而不是四个空格， 这跟python有点像，熟悉python的小伙伴应该对此比较满意233。 因此command1和command2都是指命令行命令。
通过上面的介绍， 我们可以写出下面的makefile文件：
main: src/main.cpp g&#43;&#43; src/main.cpp -o main 保存后， 进入控制台执行make, make就会自动的执行makefile文件中的第一个target。
一个稍复杂的例子 考虑下面的文件目录：
. └── src ├── a.cpp ├── a.h ├── b." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://trisolaris233.github.io/posts/old/learning-makefile-by-example/" /><meta property="og:image" content="https://trisolaris233.github.io/images/share.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-02T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2019-02-02T00:00:00&#43;00:00" /><meta property="og:site_name" content="SunshinePlusIce" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://trisolaris233.github.io/images/share.png"/>

<meta name="twitter:title" content="通过一个小项目学习Makefile"/>
<meta name="twitter:description" content="最近在linux上写了一个小项目，接触了make等工具，这次就通过一些辅助例子和我这个小项目来介绍一下makefile的基本写法。
makefile何为物  在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。
 这是来自维基百科的介绍， 其实说直白一点，就是一个编译工具。因此， 我们下载下来一个项目后， 一般会附带一个makefile文件。 更普遍的， 是附带一个configure文件，用于检查并生成需要的makefile文件，然后通过命令行执行make来编译。 执行make install来安装。
makefile的用途 考虑下面的文件目录：
. └── src └── main.cpp 如果我们位于当前目录，要编译main.cpp实在是再简单不过，于是我们张口就莱: g&#43;&#43; src/main.cpp -o main。　这样就成功编译了main.cpp文件。显然这样敲命令不会比使用makefile麻烦多少，然而这是还没到makefile大显身手的时候。
makefile的基本写法 当然，我们的目的是学习makefile，那么就以编译上面的main.cpp为例，介绍一下makefile的基本写法吧！
# 注释 target(目标): dependencies(依赖文件) &lt;tab&gt;command1 # 命令1 &lt;tab&gt;command2 # 命令2 一下子看不懂不要紧，且听我道来。target通常是我们要生成的文件的名字， dependencies是生成target所需的文件名列表， 如果为空就不需要写， 有多个文件用空格隔开。因此， 要把main.cpp编译成可执行文件main可以写成这样：main: main.cpp。
写好了target和dependencies后是换行， 接下来就要告诉makefile这个文件是如何生成出来的了。因此要键入编译指令。此处要注意&lt;tab&gt;是指一个tab键而不是四个空格， 这跟python有点像，熟悉python的小伙伴应该对此比较满意233。 因此command1和command2都是指命令行命令。
通过上面的介绍， 我们可以写出下面的makefile文件：
main: src/main.cpp g&#43;&#43; src/main.cpp -o main 保存后， 进入控制台执行make, make就会自动的执行makefile文件中的第一个target。
一个稍复杂的例子 考虑下面的文件目录：
. └── src ├── a.cpp ├── a.h ├── b."/>



<meta itemprop="name" content="通过一个小项目学习Makefile">
<meta itemprop="description" content="最近在linux上写了一个小项目，接触了make等工具，这次就通过一些辅助例子和我这个小项目来介绍一下makefile的基本写法。
makefile何为物  在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。
 这是来自维基百科的介绍， 其实说直白一点，就是一个编译工具。因此， 我们下载下来一个项目后， 一般会附带一个makefile文件。 更普遍的， 是附带一个configure文件，用于检查并生成需要的makefile文件，然后通过命令行执行make来编译。 执行make install来安装。
makefile的用途 考虑下面的文件目录：
. └── src └── main.cpp 如果我们位于当前目录，要编译main.cpp实在是再简单不过，于是我们张口就莱: g&#43;&#43; src/main.cpp -o main。　这样就成功编译了main.cpp文件。显然这样敲命令不会比使用makefile麻烦多少，然而这是还没到makefile大显身手的时候。
makefile的基本写法 当然，我们的目的是学习makefile，那么就以编译上面的main.cpp为例，介绍一下makefile的基本写法吧！
# 注释 target(目标): dependencies(依赖文件) &lt;tab&gt;command1 # 命令1 &lt;tab&gt;command2 # 命令2 一下子看不懂不要紧，且听我道来。target通常是我们要生成的文件的名字， dependencies是生成target所需的文件名列表， 如果为空就不需要写， 有多个文件用空格隔开。因此， 要把main.cpp编译成可执行文件main可以写成这样：main: main.cpp。
写好了target和dependencies后是换行， 接下来就要告诉makefile这个文件是如何生成出来的了。因此要键入编译指令。此处要注意&lt;tab&gt;是指一个tab键而不是四个空格， 这跟python有点像，熟悉python的小伙伴应该对此比较满意233。 因此command1和command2都是指命令行命令。
通过上面的介绍， 我们可以写出下面的makefile文件：
main: src/main.cpp g&#43;&#43; src/main.cpp -o main 保存后， 进入控制台执行make, make就会自动的执行makefile文件中的第一个target。
一个稍复杂的例子 考虑下面的文件目录：
. └── src ├── a.cpp ├── a.h ├── b."><meta itemprop="datePublished" content="2019-02-02T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-02-02T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="329"><meta itemprop="image" content="https://trisolaris233.github.io/images/share.png"/>
<meta itemprop="keywords" content="" />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li h3 span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }


</style>

</head>

<body>
  <header><h3>
<ul class="blog-posts">
  <li>
    
  
    
    <u><a href="https://trisolaris233.github.io/posts/old/learning-makefile-by-example/">/posts/old/Learning-Makefile-By-Example.md</a></u>
    
    
  
  
  </li>
</ul>
</h3>
  
<nav>
<a href="javascript: history.back()">Back</a>


<a href="/">Home</a>

</nav>
</header>
  <main>

<content>
  <h1>通过一个小项目学习Makefile</h1>
  <p>最近在linux上写了一个小项目，接触了make等工具，这次就通过一些辅助例子和我这个小项目来介绍一下makefile的基本写法。</p>
<h2 id="makefile何为物">makefile何为物</h2>
<blockquote>
<p>在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。</p>
</blockquote>
<p>这是来自维基百科的介绍， 其实说直白一点，就是一个编译工具。因此， 我们下载下来一个项目后， 一般会附带一个<code>makefile</code>文件。 更普遍的， 是附带一个<code>configure</code>文件，用于检查并生成需要的<code>makefile</code>文件，然后通过命令行执行<code>make</code>来编译。 执行<code>make install</code>来安装。</p>
<h2 id="makefile的用途">makefile的用途</h2>
<p>考虑下面的文件目录：</p>
<pre><code>.
└── src
    └── main.cpp
</code></pre><p>如果我们位于当前目录，要编译<code>main.cpp</code>实在是再简单不过，于是我们张口就莱: <code>g++ src/main.cpp -o main</code>。　这样就成功编译了<code>main.cpp</code>文件。显然这样敲命令不会比使用<code>makefile</code>麻烦多少，然而这是还没到<code>makefile</code>大显身手的时候。</p>
<h2 id="makefile的基本写法">makefile的基本写法</h2>
<p>当然，我们的目的是学习<code>makefile</code>，那么就以编译上面的<code>main.cpp</code>为例，介绍一下<code>makefile</code>的基本写法吧！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#75715e"># 注释
</span><span style="color:#75715e"></span><span style="color:#a6e22e">target(目标)</span><span style="color:#f92672">:</span> dependencies(依赖文件)
<span style="color:#960050;background-color:#1e0010">&lt;tab&gt;command1</span> <span style="color:#75715e"># 命令1
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">&lt;tab&gt;command2</span> <span style="color:#75715e"># 命令2
</span></code></pre></div><p>一下子看不懂不要紧，且听我道来。<code>target</code>通常是我们要生成的文件的名字， <code>dependencies</code>是生成<code>target</code>所需的文件名列表， 如果为空就不需要写， 有多个文件用空格隔开。因此， 要把<code>main.cpp</code>编译成可执行文件<code>main</code>可以写成这样：<code>main: main.cpp</code>。</p>
<p>写好了<code>target</code>和<code>dependencies</code>后是换行， 接下来就要告诉<code>makefile</code>这个文件是如何生成出来的了。因此要键入编译指令。此处要注意<code>&lt;tab&gt;</code>是指一个<code>tab</code>键而不是四个空格， 这跟<code>python</code>有点像，熟悉<code>python</code>的小伙伴应该对此比较满意233。 因此<code>command1</code>和<code>command2</code>都是指命令行命令。</p>
<p>通过上面的介绍， 我们可以写出下面的makefile文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#a6e22e">main</span><span style="color:#f92672">:</span> src/main.cpp
	g++ src/main.cpp -o main
</code></pre></div><p>保存后， 进入控制台执行<code>make</code>, <code>make</code>就会自动的执行<code>makefile</code>文件中的第一个<code>target</code>。</p>
<h2 id="一个稍复杂的例子">一个稍复杂的例子</h2>
<p>考虑下面的文件目录：</p>
<pre><code>.
└── src
    ├── a.cpp
    ├── a.h
    ├── b.cpp
    ├── b.h
    ├── c.cpp
    ├── c.h
    ├── d.cpp
    ├── d.h
    └── main.cpp

</code></pre><p>这是一个常见的小工程项目，其中<code>main.cpp</code>是主函数所在的源文件，<code>main.cpp</code>包含了<code>a.h</code>,<code>b.h</code>,<code>c.h</code>,<code>d.h</code>四个头文件，而四个头文件的功能实现分别放在对应的源文件中，先考虑如何用控制台命令编译这个项目？</p>
<p>很快我们想到了，于是章口就莱：
<code>g++ src/main.cpp src/a.cpp src/b.cpp src/d.cpp -o main</code></p>
<p>很显然4个源文件还是可以用控制台命令轻松处理， 但对于这行命令我要提出两个问题：</p>
<ol>
<li>如果我们只修改了<code>b.cpp</code> 上面的命令会导致所有源文件都重新编译。</li>
<li>4个源文件只是个例子，在一般规模的项目中，几十个源文件是司空见惯的。</li>
</ol>
<p>对于第一个问题很容易解决，只要加上<code>-c</code>选项就行， 表示生成目标文件代码(<code>.o文件</code>)；对于第二个问题最简单的解决方法就是编写一个<code>makefile</code>来控制编译。</p>
<p>于是乎， 问题变成了：如何编写这个项目的<code>makefile</code>代码？</p>
<p>根据上面的例子， 可以先考虑下我预先写完的<code>makefile</code>文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#a6e22e">main</span><span style="color:#f92672">:</span> src/main.cpp src/a.o src/b.o src/c.o src/d.o
	g++ src/main.cpp src/a.o src/b.o src/c.o src/d.o -o myhttpd

<span style="color:#a6e22e">src/a.o</span><span style="color:#f92672">:</span> src/a.cpp
	g++ -c src/a.cpp
	
<span style="color:#a6e22e">src/b.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/c.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/d.o</span><span style="color:#f92672">:</span>
</code></pre></div><p>首先第一行给出了编译<code>main</code>的方法， 它依赖于<code>src/main.cpp</code>和后面的一大堆<code>.o</code>文件。那么这些<code>.o</code>文件是哪里来的呢？  下面的代码就在说明各个.o文件是怎么出来的。 这里我用了<code>makefile</code>比较良心的智能推断。 我只写了<code>src/a.o</code>依赖于<code>src/a.cpp</code>， 接下来的几个用不着我细说<code>makefile</code>就明白并且在执行时会自动编译。</p>
<p>接下来又出现了问题，这样编译会导致目录下有很多<code>.o</code>文件，如果哪一天我不需要了怎么清除他们呢？ 这个用命令行一样好办， <code>makefile</code>也可以帮忙解决这个问题。 我们只消在原来的文件中加上：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
	rm src/*.o
</code></pre></div><p>然后执行<code>make clean</code>就可以啦！</p>
<p>通过上面的例子我们知道<code>makefile</code>的<code>target</code>不是仅仅文件而已， 解释成<code>任务</code>或许更好。这样可以帮助我们对<code>makefile</code>的理解。<code>makefile</code>默认只执行第一个<code>target</code>和其依赖的文件。</p>
<h2 id="改进makefile">改进makefile</h2>
<p>考虑这样一个情景： 你写了一个项目， 也编写了<code>makefile</code>，但你发现<code>g++</code>简直是傻逼！ 你决定换成<code>clang</code>编译器， 这该如何是好？</p>
<p>你灵稽一动， 想到可以用一般文本编辑器都带的文本替换功能， 把所有<code>g++</code>换成<code>clang</code>就可以了， 这显然是个挺好的解决方案， 不过我们可以改进<code>makefile</code>文件的写法，就可以用一种更加优雅的方式解决这个问题（程序员总是强调**<code>优雅</code>**这个问题）</p>
<p>我们可以为<code>makefile</code>设置变量来改， <code>makefile</code>中变量的设置和其他语言不无二致。 举个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile">CC <span style="color:#f92672">=</span> g++

<span style="color:#a6e22e">main</span><span style="color:#f92672">:</span> src/main.cpp
	<span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> src/main.cpp -o main <span style="color:#75715e"># $(CC)就是g++</span>
</code></pre></div><p>这就是<code>makefile</code>中变量的设定。 是不是很简单？ 如果有多个， 用空格隔开就行， 调用的时候也是一样的。 这样一来， 我们就可以改写我们上面的<code>makefile</code>了！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile">CC <span style="color:#f92672">=</span> g++
CFLAGS <span style="color:#f92672">=</span> -std<span style="color:#f92672">=</span>c++11	<span style="color:#75715e"># 设置编译选项变量 表示启用c++11标准</span>
OBJS <span style="color:#f92672">=</span> src/a.o src/b.o src/c.o src/d.o	<span style="color:#75715e"># 设置目标代码文件变量</span>

<span style="color:#a6e22e">main</span><span style="color:#f92672">:</span> src/main.cpp <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span>
	<span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>CFLAGS<span style="color:#66d9ef">)</span> src/main.cpp <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span> -o main

<span style="color:#a6e22e">src/a.o</span><span style="color:#f92672">:</span> src/a.cpp
	g++ -c src/a.cpp
	
<span style="color:#a6e22e">src/b.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/c.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/d.o</span><span style="color:#f92672">:</span>

<span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>	<span style="color:#75715e"># 清除.o文件
</span><span style="color:#75715e"></span>	rm src/*.o
	
<span style="color:#a6e22e">install</span><span style="color:#f92672">:</span>	<span style="color:#75715e"># 使用cp命令安装到可执行文件目录
</span><span style="color:#75715e"></span>	sudo cp main /usr/bin/main
</code></pre></div><p>这样一来， 我们就可以执行<code>make</code>来编译。 <code>make clean</code>来删除不必要的文件， <code>make install</code>来安装软件。 如果需要更换编器的画就把<code>CC = g++</code>换成<code>CC = clang</code>就可以了！</p>
<h2 id="例子-myhttpd项目">例子: myhttpd项目</h2>
<p>学习了上面<code>makefile</code>的基本写法之后， 来观察一下<a href="https://github.com/trisolaris233/myhttpd"><code>myhttpd</code></a>项目的文件目录：</p>
<pre><code>.
├── LICENSE
├── makefile
├── README.md
└── src
    ├── compress.cpp
    ├── compress.h
    ├── myhttpd.cpp
    ├── parse.cpp
    ├── parse.h
    ├── request.cpp
    ├── request.h
    ├── response.cpp
    ├── response.h
    ├── server.cpp
    ├── server.h
    ├── socket.cpp
    ├── socket.h
    ├── tools.cpp
    ├── tools.h
    └── welcome
        ├── index.html
        └── myhttpd.png
</code></pre><p>编译这个项目的<code>makefile</code>文件如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile">CC <span style="color:#f92672">=</span> g++
CFLAGS <span style="color:#f92672">=</span> -std<span style="color:#f92672">=</span>c++11 -lz <span style="color:#75715e"># 启用C++11， 链接zlib</span>
OBJS <span style="color:#f92672">=</span> src/parse.o src/request.o src/response.o src/socket.o src/tools.o src/compress.o src/server.o

<span style="color:#a6e22e">myhttpd</span><span style="color:#f92672">:</span> src/myhttpd.cpp <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span>
	<span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>CFLAGS<span style="color:#66d9ef">)</span> src/myhttpd.cpp <span style="color:#66d9ef">$(</span>OBJS<span style="color:#66d9ef">)</span> -o myhttpd

<span style="color:#a6e22e">src/parse.o</span><span style="color:#f92672">:</span> src/parse.cpp
<span style="color:#a6e22e">src/request.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/response.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/socket.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/tools.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/compress.o</span><span style="color:#f92672">:</span>
<span style="color:#a6e22e">src/server.o</span><span style="color:#f92672">:</span>

<span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
	rm src/*.o

<span style="color:#a6e22e">install</span><span style="color:#f92672">:</span>
	sudo cp ./myhttpd /usr/bin/myhttpd
</code></pre></div><p>相信通过上面的学习可以轻易的理解这段<code>makefile</code>代码， 而且我们发现通过<code>makefile</code>代码可以更加容易的观察各个文件的依赖关系。</p>
<h2 id="后记">后记</h2>
<p><code>makefile</code>是学习编程中或多或少会接触到的东西，今天通过一些实例简单的介绍了一下<code>make</code>这个使用的工具，希望能对大家有所帮助。</p>
<p>本篇博文只是介绍了<code>makefile</code>的冰山一角， 本人也在学习的路上。</p>

</content>
<p>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

    
</body>

</html>
