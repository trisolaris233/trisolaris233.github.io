---
title: 乱学数字电路（一）：教练我想学这个
tags:
  - Programming
abbrlink: 41944
date: 2020-04-03 23:41:20
---

## Notice

{% blockquote %}

这不是一篇很严谨的教程，但也不是粗制滥造的教程。

{% endblockquote %}

明确来说，这应该是我吧我自己的学习笔记写成跟教程一样，一方面可以总结自己，一方面还可以在别人身上创造价值。

这些笔记肯定不适合新手真正想系统学点东西，但是没有意外的话，应该可以了解到一些东西。

这些文章应该会带着很多我自己的风格，有时候还会出来几句梗和祖安用语，如果不介意的话可以往下看哦。



## Foreword

最近在读《Digital Fundamental》这本书，这本书整一个就是一个教材编排，有设置一些练习题什么的，用来入门挺不错的。数字电路是一门挺基础的学科，怎么说的，不懂不影响你写代码（或者影响不大），但是了解数字电路的话会对写代码有帮助就是了。我自己就是在读这本书的时候想明白了以前想不明白的一些问题。



因为这本书内容太多了，我不可能全部都写上来，我挑一些我觉得重要的东西说吧。

因为我读的是英文的，我不太知道中文是怎么描述的，但是语言毕竟只是语言而已，我不是要说名词怎样怎样，只要能让看的人明白就可以了。



{% blockquote %}

写这个文章的时候是3号4号之交，写这段话的时候已经是4号凌晨了。

我的态度是在疫情最危急的时候，战斗在前线的医护人员和各路志愿者都是非常值得尊敬的，他们的职业操守和人格值得我们敬仰，RIP。

{% endblockquote %}

## Basis of Basis

要介绍数字电路，就要引入另一个概念就是模拟电路(analog electronics)。他们是用来干什么的呢，是用来表示量(quantity)的，简单地说，就是表示数字的。

他们的区别在于，数字电路表示的量是不连续的，而模拟电路表示的量是连续的。什么意思呢，比如你考试考数学，第一次考了2分，第二次考了-12分，第三次考了0.5分，这个就是数字电路。这些量，这里的实际意义就是数学考试的分数，是不连续的。

如果是模拟电路那怎样呢，比如说温度的升高，你的体温从35℃降到了20℃(~~请无视为什么是体温233~~)不可能从35℃一下子就掉到了20℃，所以是一点点下降的，这种东西就叫做模拟电路。

如果以纵坐标表示电压，横坐标表示时间，那么电压随时间的变化可以画成这样的图：







数字电路的特点就是不连续，听说过计算机的人都知道，计算机只认0和1，这是为什么呢。我画出来的图明明有很多不一样的电压值，怎么就变成只有0和1了？

因为电压值总是不断变化的，所以为了简化这个模型，比如你这个东西，电压就只在0.5V和1.5V之间反复横跳，那么我取一段，比如1.4V到1.5V定为HIGH，如果电压落在了这个范围里面，就是1.

所以不落在这个范围里就是0？也不是，还要取一段，落在这一段是0。这个取值的规则就是不能有重复的，比如0.7V即被标记为HIGH又被标记为LOW，那么这个0.7V就是个双标的婊子，是不被允许的。

取值同时也不必把所有值都取完，比如一定要对半分之类的，只要合理即可。如果电压落在了规定以外的范围，既不属于HIGH也不属于LOW，那么他就是一个无下限的舔狗，不是不被允许，只是不会被表示成0和1而已。

被简化的数字电路只剩下了0和1两种状态，所以我们说计算机只认0和1，因为他的模型很简单。这种模型下的数字电路大概是这个样子的：



好了，关于数字电路我觉得到这里就可以了，中间有一些东西还是要说就挺多了，如果要了解就自己去看书。



## Basic Logic Function

这个东西哪怕平生从未接触数字电路的人也很清楚，比如'NOT','AND'和'OR'等等等。这三个可能是最常用的。这个在编程语言里面就是所谓的位运算的几个运算符，看起来好像没什么了不起的，实际上在数字电路里面，这几个Gate（Gate指门，比如NOT就是非门，门，就是实现他们的电路）就是一切啊。



在数字电路里面，一般可以用图来表示这几个Gate。就像下面这样。



其中左边的线表示INPUT,右边的线表示OUTPUT，不难发现，NOT只接受一个INPUT，得到一个OUTPUT。AND可以接受1个以上的INPUT平行输入，有几个INPUT就有几条线，OR也是如此。

可以看到NOT的右边尖有一个圈，这个圈是干什么的？这个圈(bubble)表示“反”，什么意思呢？如果不明白，可以把圈拿掉，就变成了这个样子：





为了方便理解，首先要说说NOT的作用，NOT的作用就是“反”。什么意思呢，比如NOT的左边输入的是HIGH，那么右边出来的就是LOW。反过来左边输入LOW，右边就是HIGH。很容易理解嘛，就是反啊。

然后我们也提到那个圈就是反，而且观察圈所处的位置，是不是在输出位置？这就对了。所以这个NOT的图像就表示，输入，在输出的时候反一反。所以就成了NOT。因为AND和OR都不需要反，所以他们就没有圈。





### AND Gate

如果学过编程，那么AND就很好理解，简单来说，AND只有在输入都是1的时候输出1,其他情况一律输出0。

如果没有学过编程，AND表示的逻辑含义就是“与”或者“和”。一般我们认为1代表的是True，也就是真。输入的相当于就是条件，只有所有条件都是真，输出才是真，当有一个条件不是真，为False的时候那么输出就是假，就是0了。



### OR Gate

OR在逻辑上表示的是“或者”，意思是说，输入中只要有一个是1就输出1。换一种说法，除了输入全部是0的情况OR输出0，其他情况OR的输出都是1。





### 带圈的其他的Gates

了解了AND和OR之后，也整明白那个圈是怎么回事的时候，就可以介绍另外的一些Gate了，比如说NAND啊，比如说NOR啊，还有Negative-And和Negative-OR，可以先一睹他们的芳容：



我们很容易理解，NAND就是在AND的基础上，把输出反一下，在脑子里就可以模拟一下，原来的AND是要所有都是1他才输出1.现在变成了所有都是1他要输出0.其他情况都变成了1。反过来看这个Negative-AND,这个不是反输出，而是反了输入，也很容易知道，原来AND是输入全1输出1，那么Negative-AND就是输入全0输出1.其他情况一律输出0。

NOR是在OR的基础上反了输出，原来的OR是只要有1就输出1，那么NOR是只要有1就输出0，所有都是0才输出1。Negative-OR是在OR的基础上反了输入，原来OR只要有1个1就输出1，Negative-OR就是只要有1个0就输出1, 只有全部都是1的情况就输出0。



这些都是不需要任何记忆的，就是简单的模拟就可以得出的结论。当然还有一些有意思的东西，仔细观察，NAND和Negative-OR的效果是一模一样的。这个能记住当然很好，记不住也可以模拟出来。

所以我们可以得出这些结论：

```
NAND = Negative-OR
NOR = Negative-AND
```



这些就是一些基础的门的内容，实际上还有一些Gates，比如Exclusive-OR啦... 相信有了上面一些基础，对Gate就会有足够的理解了。





## Complement makes things work（补码）

要学习下面的内容，你需要保证你在下面的属性中有技能点分配：

{% blockquote %}

​	***智慧***：

- 基本了解二进制及其计算方式

- 知道bit，byte等基本的计算机单位

  

  ***生命***:

- 知道如何在二进制和十进制中转换



​	***精明***:

- 粗略懂一些洋文单词

{% endblockquote %}



要用补码肯定是因为一般的二进制他不行，所以才要用补码。我们可以看看一般的二进制是怎么做的，遇到了什么问题需要引入补码，解决了这个问题，剩下的就迎刃而解了。



我们知道二进制是计算机唯一可以理解的方式，我们也基本知道数字是怎么被二进制表示的。一般说来，一串二进制数字都有最左边和左右边两个位，最左边的权是最大的，所以就叫做Most Significant Bit,最右边的权是最低的，称为Least Significant Bit，所以这两个位就可以分别简称做MSB和LSB。



然后表示数字，数字又有符号，有负数，有正数，怎么办呢？



容易想到的做法就是弄出一位来做符号，哪一位？MSB还是LSB？肯定有人和我一样一开始认为LSB吼啊，LSB反正那么小，就用他做符号了，还能存好多数字。实际上再仔细想想，你发现少了LSB二进制数就只能表示偶数了！表示不了奇数了，所以果断放弃掉，选择MSB，虽然少了很多可以表示的数字，但毕竟保存了完整性。一般来说，计算机就是用MSB存储符号，0表示为正数，1表示负数。如果全是二进制位全是0，那么就是0，所以0在计算机看来，或许就是一个正数。



假设二进制位有n个，那么表示的范围就在`[-2^(n-1),2^(n-1)-1]`，为什么正数少了一个的原因就在于0也被算作是个正数。



### 二进制的简单计算

这里从二进制的加法来说，二进制的加法和十进制的加法非常类似，和十进制不一样的地方是，二进制是到2进1，十进制是到10进1，比如我有两个二进制数00001010和二进制数00101011，就可以按照下面的方法来计算



这样可以正确获得结果，但是如果其中一个是负数，那么直接计算肯定不能获得我们想要的结果，因为直接计算会把符号位的1当做数字来看待，gg是肯定的。难道要把符号位分开讨论？这也有问题，比如数字-6和4，除开符号位剩下的二进制位表示的是6和4，他们相加是10。就算单独考虑符号结果也只可能是10和-10。这很明显也是错的。



所以我们发现，纯的二进制数在表示有符号的数字的时候并不好使，因为我们用了一个位来表示符号。也就是说纯的二进制数没有办法直接通过相加的办法实现含有负数的相加，只能实现都是正数的相加。

于是补码就应运而生了。



### 补码是如何获得的

补码的英文名是2's complement,有2就有1，1's complement中文就叫做反码了。反码很容易理解，和前面介绍的非门息息相关，反码就是讲二进制数的所有1换成0，所有0换成1。反码在二进制数上的特征很明显，就是每个位都反了，如果把二进制数转换成10进制数会不会也有特性？答案是有的，一个二进制数的10进制和他的反码的10进制数的关系也是非常明显的，我们令前者为A，后者为B，你可以自己拉两个例子出来，很容易就可以得到`-(|A| + 1) = B`

那么补码呢？补码就是在反码的基础上+1。那么10进制关系就更加明显了，令原二进制数的十进制为A，他的补码的十进制数为B，有A = -B

这里有一个问题，是怎么计算负数的十进制数，假设有一个8位的二进制负数10010010,如何计算他的10进制数？这个和正数的十进制数计算稍微有一点差别，他的计算方法是-1*2^7 + 1*2^4 + 1*2^1，就是如果符号位是1，那么就用-1乘上对应的权数，其他不变。



### 为什么需要补码

$f(x) = a + b$

















